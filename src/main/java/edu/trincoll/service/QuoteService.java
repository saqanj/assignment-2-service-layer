package edu.trincoll.service;

import edu.trincoll.model.Quote;
import edu.trincoll.repository.QuoteRepository;
import edu.trincoll.repository.Repository;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * ---AI Collaboration Summary-------------
 * -
 * - Helper methods norm(), lower(), isBlank(), safeCategory() and safeTags() generated by ChatGPT.
 * - ChatGPT used to help explain streams, filter, flatmaps, and other functional programming features.
 * -
 * ----------------------------------------
 * Service layer implementing business logic.
 * Extends BaseService for common CRUD operations.
 */
@Service
public class QuoteService extends BaseService<Quote, Long> {
    
    private final QuoteRepository repository;
    
    public QuoteService(QuoteRepository repository) {
        this.repository = repository;
    }
    
    @Override
    protected Repository<Quote, Long> getRepository() {
        return repository;
    }
    
    @Override
    public void validateEntity(Quote entity) {
        if (entity == null) {
            throw new IllegalArgumentException("Quote cannot be null");
        }

        // ----------------
        // Title validation
        // ----------------
        if (entity.getTitle() == null || entity.getTitle().trim().isEmpty()) {
            throw new IllegalArgumentException("Title is required");
        }
        if (entity.getTitle().length() > 100) {
            throw new IllegalArgumentException("Title cannot exceed 100 characters");
        }

        // ----------------
        // Description validation
        // ----------------
        if (entity.getDescription() != null && entity.getDescription().length() > 1000) {
            throw new IllegalArgumentException("Description cannot exceed 1000 characters");
        }

        // ----------------
        // Category validation
        // ----------------
        if (entity.getCategory() != null && entity.getCategory().length() > 50) {
            throw new IllegalArgumentException("Category cannot exceed 50 characters");
        }

        // ----------------
        // Author validation
        // ----------------
        if (entity.getAuthor() != null && entity.getAuthor().length() > 100) {
            throw new IllegalArgumentException("Author name cannot exceed 100 characters");
        }

        // ----------------
        // Source validation
        // ----------------
        if (entity.getSource() != null && entity.getSource().length() > 200) {
            throw new IllegalArgumentException("Source cannot exceed 200 characters");
        }

        // ----------------
        // Publisher validation
        // ----------------
        if (entity.getPublisher() != null && entity.getPublisher().length() > 100) {
            throw new IllegalArgumentException("Publisher cannot exceed 100 characters");
        }

        // ----------------
        // Tag validation
        // ----------------
        if (entity.getTags() != null) {
            if (entity.getTags().size() > 20) {
                throw new IllegalArgumentException("A quote cannot have more than 20 tags");
            }
            for (String tag : entity.getTags()) {
                if (tag == null || tag.trim().isEmpty()) {
                    throw new IllegalArgumentException("Tags cannot be blank");
                }
                if (tag.length() > 30) {
                    throw new IllegalArgumentException("Tag cannot exceed 30 characters: " + tag);
                }
            }
        }
        // ----------------
        // Status validation
        // ----------------
        if (entity.getStatus() == null) {
            throw new IllegalArgumentException("Status must not be null");
        }
    }

    // ------------------------
    // Helpers
    // ------------------------
    /**
     * Removes leading and trailing whitespace if string is not null
     */
    private static String norm(String s) {
        return s == null ? "" : s.trim();
    }

    /**
     * Converts string to lowercase
     */
    private static String lower(String s) {
        return norm(s).toLowerCase(Locale.ROOT);
    }

    /**
     * Returns true if string is empty
     */
    private static boolean isBlank(String s) {
        return norm(s).isEmpty();
    }

    /**
     * Returns a quotes category or "Uncategorized" if category is empty
     */
    private static String safeCategory(Quote q) {
        String c = q.getCategory();
        return isBlank(c) ? "Uncategorized" : c.trim();
    }

    /**
     * Returns a quotes tags or an empty set if it has none
     */
    private static Set<String> safeTags(Quote q) {
        Set<String> t = q.getTags();
        return (t == null) ? Collections.emptySet() : t;
    }


    /**
     * Find items by status
     */
    public List<Quote> findByStatus(Quote.Status status) {
        return repository.findByStatus(status);
    }
    
    /**
     * Find items by category
     */
    public List<Quote> findByCategory(String category) {
        return repository.findByCategory(category);
    }
    
    /**
     * Group items by category using Collectors
     */
    public Map<String, List<Quote>> groupByCategory() {
        return repository.findAll().stream()
                .collect(Collectors.groupingBy(QuoteService::safeCategory));
    }
    
    /**
     * Get all unique tags from all items
     */
    public Set<String> getAllUniqueTags() {
        return repository.findAll().stream()
                .map(QuoteService::safeTags)
                .flatMap(Set::stream)
                .collect(Collectors.toCollection(TreeSet::new)); // sorted & unique
    }
    
    /**
     * Get count of items per status
     */
    public Map<Quote.Status, Long> countByStatus() {
        EnumMap<Quote.Status, Long> result = new EnumMap<>(Quote.Status.class);
        // Start with 0 for each status
        for (Quote.Status s : Quote.Status.values()) {
            result.put(s, 0L);
        }
        // Count present
        Map<Quote.Status, Long> counts = repository.findAll().stream()
                .collect(Collectors.groupingBy(Quote::getStatus, () -> new EnumMap<>(Quote.Status.class), Collectors.counting()));
        // Merge
        counts.forEach((k, v) -> result.put(k, v));
        return result;
    }
    
    /**
     * Find items with multiple tags (AND operation)
     */
    public List<Quote> findByAllTags(Set<String> tags) {
        if (tags == null || tags.isEmpty()) return Collections.emptyList();
        Set<String> wanted = tags.stream().filter(Objects::nonNull)
                .map(QuoteService::lower)
                .filter(s -> !s.isEmpty())
                .collect(Collectors.toSet());
        if (wanted.isEmpty()) return Collections.emptyList();

        return repository.findAll().stream()
                .filter(q -> safeTags(q).containsAll(wanted))
                .collect(Collectors.toList());
    }
    
    /**
     * Find items with any of the tags (OR operation)
     */
    public List<Quote> findByAnyTag(Set<String> tags) {
        if (tags == null || tags.isEmpty()) return Collections.emptyList();
        Set<String> wanted = tags.stream().filter(Objects::nonNull)
                .map(QuoteService::lower)
                .filter(s -> !s.isEmpty())
                .collect(Collectors.toSet());
        if (wanted.isEmpty()) return Collections.emptyList();

        return repository.findAll().stream()
                .filter(q -> {
                    Set<String> qt = safeTags(q);
                    // intersect non-empty?
                    for (String w : wanted) {
                        if (qt.contains(w)) return true;
                    }
                    return false;
                })
                .collect(Collectors.toList());
    }
    
    /**
     * Get most popular tags (top N by frequency)
     */
    public List<String> getMostPopularTags(int limit) {
        if (limit <= 0) return Collections.emptyList();

        Map<String, Long> freq = repository.findAll().stream()
                .map(QuoteService::safeTags)
                .flatMap(Set::stream)
                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));

        return freq.entrySet().stream()
                .sorted(Comparator.<Map.Entry<String, Long>>comparingLong(Map.Entry::getValue).reversed()
                        .thenComparing(Map.Entry::getKey))
                .limit(limit)
                .map(Map.Entry::getKey)
                .collect(Collectors.toList());
    }
    
    /**
     * Search items by query (searches title and description)
     */
    public List<Quote> search(String query) {
        String needle = lower(query);
        if (needle.isEmpty()) return Collections.emptyList();

        return repository.findAll().stream()
                .filter(q -> {
                    // strings
                    boolean inTitle      = lower(q.getTitle()).contains(needle);
                    boolean inDesc       = lower(q.getDescription()).contains(needle);
                    boolean inCategory   = lower(q.getCategory()).contains(needle);
                    boolean inAuthor     = lower(q.getAuthor()).contains(needle);
                    boolean inSource     = lower(q.getSource()).contains(needle);
                    boolean inPublisher  = lower(q.getPublisher()).contains(needle);

                    // tags (case-insensitive substring match)
                    boolean inTags = false;
                    Set<String> tags = q.getTags();
                    if (tags != null && !tags.isEmpty()) {
                        for (String t : tags) {
                            if (t != null && lower(t).contains(needle)) {
                                inTags = true;
                                break;
                            }
                        }
                    }

                    return inTitle || inDesc || inCategory || inAuthor || inSource || inPublisher || inTags;
                })
                .collect(Collectors.toList());
    }


    /**
     * Archive old items (change status to ARCHIVED)
     */
    public int archiveInactiveItems() {
        List<Quote> inactive = repository.findByStatus(Quote.Status.INACTIVE);
        int updated = 0;
        for (Quote q : inactive) {
            q.setStatus(Quote.Status.ARCHIVED);
            repository.save(q);
            updated++;
        }
        return updated;
    }
}